#!/usr/bin/env node

const util = require('util')
const fs = require('fs')
const program = require('commander')
const request = require('request-promise-native')
const parseXml = require('xml2js').parseString
const handlebars = require('handlebars')

let version = ''
try {
    version = require('jinqu-odata-cli/package.json').version
} catch {
    try {
        version = require('../package.json').version
    } catch {}
}

program
    .version(version)
    .description('jinqu-odata CLI code generator')
    .option('-u, --url <odata url>', 'OData Metadata Url')
    .option('-o, --out [out]', 'Output file path', 'metadata.ts')
    .option('-i [interface]', 'Use interfaces for types')
    .option('-d [decorators]', 'Use decorators')
    .option('-n [nonNullAssertion]', 'Use non-null assertions')
    .parse(process.argv)

const useInterfaces = program.I
const useDecorators = !useInterfaces && program.D
const useNonNullAssertions = !useInterfaces && program.N

async function loadMetadata() {
    const response = await request.get(program.url)
    const metadata = await util.promisify(parseXml)(response)
    const schema = metadata['edmx:Edmx']['edmx:DataServices'][0]['Schema'][0]

    const compiledTemplate = handlebars.compile(template, {
        noEscape: true
    })

    schema.date = new Date().toLocaleString()
    schema.version = version
    schema.useInterfaces = useInterfaces
    schema.useDecorators = useDecorators

    const output = compiledTemplate(schema)

    fs.writeFileSync(program.out, output)
}

function registerHelpers() {
    handlebars.registerHelper('getType', type => {
        switch (type) {
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64':
            case 'Edm.Single':
            case 'Edm.Double':
            case 'Edm.Decimal':
                return 'number'
            case 'Edm.String':
            case 'Edm.Date':
            case 'Edm.DateTimeOffset':
            case 'Edm.TimeOfDay':
            case 'Edm.Byte':
            case 'Edm.SByte':
                return 'string'
            case 'Edm.Boolean':
            case 'Edm.Binary':
                return 'boolean'
            default:
                return 'any'
        }
    })

    handlebars.registerHelper('setNavigationInfo', navigation => {
        const type = navigation.Type
        const getType = t => t.split('.').pop()

        if (type.startsWith('Collection(')) {
            navigation.isCollection = true
            navigation.typeName = `${getType(type.substring(11, type.length - 1))}[]`
        } else {
            navigation.isCollection = false
            navigation.typeName = getType(type)
        }
    })

    handlebars.registerHelper('nonNullAssertion', property => {
        return useNonNullAssertions && property.Nullable == 'false' ? '!' : ''
    })

    handlebars.registerHelper('getClassDecorator', entityType => {
        return useDecorators ? `oDataResource('${entityType.$.Name}')\n` : ''
    })

    handlebars.registerHelper('getPropertyDecorator', (property, entityType) => {
        const decorate = useDecorators 
            && entityType.Key.find(k => k.PropertyRef.find(p => p.$.Name === property.Name)) != null
        return decorate ? '@oDataKey ' : ''
    })

    handlebars.registerHelper('getNavigationDecorator', property => {
        return useDecorators ? `@Type(${property.typeName}) ` : ''
    })
}

registerHelpers()
loadMetadata()

const template =
`/* This code was generated by jinqu-odata code generator */
/* tslint:disable */
{{#if useDecorators}}
import { oDataResource, oDataKey } from 'jinqu-odata';
import { Type } from 'class-transformer';
{{/if}}
{{#each ComplexType}}

export interface {{$.Name}} {
    {{#each Property}}
    {{$.Name}}: {{getType $.Type}};
    {{/each}}
}
{{/each}}
{{#each EntityType as | entityType |}}

{{getClassDecorator entityType}}export {{#if useInterfaces}}interface{{else}}class{{/if}} {{$.Name}} {
    {{#each Property}}
    {{getPropertyDecorator $ entityType}}{{$.Name}}{{nonNullAssertion $}}: {{getType $.Type}};
    {{/each}}
    {{#each NavigationProperty}}
    {{setNavigationInfoÂ $}}{{getNavigationDecorator $}}{{$.Name}}{{nonNullAssertion $}}: {{$.typeName}};
    {{/each}}
}
{{/each}}
{{#each EnumType}}

export enum {{$.Name}} {
    {{#each Member}}
    {{$.Name}} = {{$.Value}}{{#unless @last}},{{/unless}}
    {{/each}}
}
{{/each}}`
